diff -urN nfs-utils-1.0.7.old/support/export/mount.h nfs-utils-1.0.7/support/export/mount.h
--- nfs-utils-1.0.7.old/support/export/mount.h	1970-01-01 01:00:00.000000000 +0100
+++ nfs-utils-1.0.7/support/export/mount.h	2006-03-24 15:39:43.000000000 +0100
@@ -0,0 +1,469 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _MOUNT_H_RPCGEN
+#define _MOUNT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+#ifndef IXDR_GET_INT32
+#define IXDR_GET_INT32(buf) IXDR_GET_LONG((buf))
+#endif
+#ifndef IXDR_PUT_INT32
+#define IXDR_PUT_INT32(buf, v) IXDR_PUT_LONG((buf), (v))
+#endif
+#ifndef IXDR_GET_U_INT32
+#define IXDR_GET_U_INT32(buf) IXDR_GET_U_LONG((buf))
+#endif
+#ifndef IXDR_PUT_U_INT32
+#define IXDR_PUT_U_INT32(buf, v) IXDR_PUT_U_LONG((buf), (v))
+#endif
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user or with the express written consent of
+ * Sun Microsystems, Inc.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+/*
+ * Copyright (c) 1985, 1990 by Sun Microsystems, Inc.
+ */
+
+/* from @(#)mount.x	1.3 91/03/11 TIRPC 1.0 */
+#ifndef _rpcsvc_mount_h
+#define _rpcsvc_mount_h
+#include <memory.h>
+#define MNTPATHLEN 1024
+#define MNTNAMLEN 255
+#define FHSIZE 32
+
+typedef char fhandle[FHSIZE];
+#ifdef __cplusplus 
+extern "C" bool_t xdr_fhandle(XDR *, fhandle);
+#elif __STDC__ 
+extern  bool_t xdr_fhandle(XDR *, fhandle);
+#else /* Old Style C */ 
+bool_t xdr_fhandle();
+#endif /* Old Style C */ 
+
+
+struct fhstatus {
+	u_int fhs_status;
+	union {
+		fhandle fhs_fhandle;
+	} fhstatus_u;
+};
+typedef struct fhstatus fhstatus;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_fhstatus(XDR *, fhstatus*);
+#elif __STDC__ 
+extern  bool_t xdr_fhstatus(XDR *, fhstatus*);
+#else /* Old Style C */ 
+bool_t xdr_fhstatus();
+#endif /* Old Style C */ 
+
+
+typedef char *dirpath;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_dirpath(XDR *, dirpath*);
+#elif __STDC__ 
+extern  bool_t xdr_dirpath(XDR *, dirpath*);
+#else /* Old Style C */ 
+bool_t xdr_dirpath();
+#endif /* Old Style C */ 
+
+
+typedef char *name;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_name(XDR *, name*);
+#elif __STDC__ 
+extern  bool_t xdr_name(XDR *, name*);
+#else /* Old Style C */ 
+bool_t xdr_name();
+#endif /* Old Style C */ 
+
+
+typedef struct mountbody *mountlist;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountlist(XDR *, mountlist*);
+#elif __STDC__ 
+extern  bool_t xdr_mountlist(XDR *, mountlist*);
+#else /* Old Style C */ 
+bool_t xdr_mountlist();
+#endif /* Old Style C */ 
+
+
+struct mountbody {
+	name ml_hostname;
+	dirpath ml_directory;
+	mountlist ml_next;
+};
+typedef struct mountbody mountbody;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountbody(XDR *, mountbody*);
+#elif __STDC__ 
+extern  bool_t xdr_mountbody(XDR *, mountbody*);
+#else /* Old Style C */ 
+bool_t xdr_mountbody();
+#endif /* Old Style C */ 
+
+
+typedef struct groupnode *groups;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_groups(XDR *, groups*);
+#elif __STDC__ 
+extern  bool_t xdr_groups(XDR *, groups*);
+#else /* Old Style C */ 
+bool_t xdr_groups();
+#endif /* Old Style C */ 
+
+
+struct groupnode {
+	name gr_name;
+	groups gr_next;
+};
+typedef struct groupnode groupnode;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_groupnode(XDR *, groupnode*);
+#elif __STDC__ 
+extern  bool_t xdr_groupnode(XDR *, groupnode*);
+#else /* Old Style C */ 
+bool_t xdr_groupnode();
+#endif /* Old Style C */ 
+
+
+typedef struct exportnode *exports;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_exports(XDR *, exports*);
+#elif __STDC__ 
+extern  bool_t xdr_exports(XDR *, exports*);
+#else /* Old Style C */ 
+bool_t xdr_exports();
+#endif /* Old Style C */ 
+
+
+struct exportnode {
+	dirpath ex_dir;
+	groups ex_groups;
+	exports ex_next;
+};
+typedef struct exportnode exportnode;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_exportnode(XDR *, exportnode*);
+#elif __STDC__ 
+extern  bool_t xdr_exportnode(XDR *, exportnode*);
+#else /* Old Style C */ 
+bool_t xdr_exportnode();
+#endif /* Old Style C */ 
+
+
+struct ppathcnf {
+	int pc_link_max;
+	short pc_max_canon;
+	short pc_max_input;
+	short pc_name_max;
+	short pc_path_max;
+	short pc_pipe_buf;
+	u_char pc_vdisable;
+	char pc_xxx;
+	short pc_mask[2];
+};
+typedef struct ppathcnf ppathcnf;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_ppathcnf(XDR *, ppathcnf*);
+#elif __STDC__ 
+extern  bool_t xdr_ppathcnf(XDR *, ppathcnf*);
+#else /* Old Style C */ 
+bool_t xdr_ppathcnf();
+#endif /* Old Style C */ 
+
+#define FHSIZE3 64
+
+typedef struct {
+	u_int fhandle3_len;
+	char *fhandle3_val;
+} fhandle3;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_fhandle3(XDR *, fhandle3*);
+#elif __STDC__ 
+extern  bool_t xdr_fhandle3(XDR *, fhandle3*);
+#else /* Old Style C */ 
+bool_t xdr_fhandle3();
+#endif /* Old Style C */ 
+
+
+enum mountstat3 {
+	MNT_OK = 0,
+	MNT3ERR_PERM = 1,
+	MNT3ERR_NOENT = 2,
+	MNT3ERR_IO = 5,
+	MNT3ERR_ACCES = 13,
+	MNT3ERR_NOTDIR = 20,
+	MNT3ERR_INVAL = 22,
+	MNT3ERR_NAMETOOLONG = 63,
+	MNT3ERR_NOTSUPP = 10004,
+	MNT3ERR_SERVERFAULT = 10006,
+};
+typedef enum mountstat3 mountstat3;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountstat3(XDR *, mountstat3*);
+#elif __STDC__ 
+extern  bool_t xdr_mountstat3(XDR *, mountstat3*);
+#else /* Old Style C */ 
+bool_t xdr_mountstat3();
+#endif /* Old Style C */ 
+
+
+struct mountres3_ok {
+	fhandle3 fhandle;
+	struct {
+		u_int auth_flavors_len;
+		int *auth_flavors_val;
+	} auth_flavors;
+};
+typedef struct mountres3_ok mountres3_ok;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountres3_ok(XDR *, mountres3_ok*);
+#elif __STDC__ 
+extern  bool_t xdr_mountres3_ok(XDR *, mountres3_ok*);
+#else /* Old Style C */ 
+bool_t xdr_mountres3_ok();
+#endif /* Old Style C */ 
+
+
+struct mountres3 {
+	mountstat3 fhs_status;
+	union {
+		mountres3_ok mountinfo;
+	} mountres3_u;
+};
+typedef struct mountres3 mountres3;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountres3(XDR *, mountres3*);
+#elif __STDC__ 
+extern  bool_t xdr_mountres3(XDR *, mountres3*);
+#else /* Old Style C */ 
+bool_t xdr_mountres3();
+#endif /* Old Style C */ 
+
+#endif /*!_rpcsvc_mount_h*/
+
+#define MOUNTPROG ((u_int32_t)100005)
+#define MOUNTVERS ((u_int32_t)1)
+
+#ifdef __cplusplus
+#define MOUNTPROC_NULL ((u_int32_t)0)
+extern "C" void * mountproc_null_1(void *, CLIENT *);
+extern "C" void * mountproc_null_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_MNT ((u_int32_t)1)
+extern "C" fhstatus * mountproc_mnt_1(dirpath *, CLIENT *);
+extern "C" fhstatus * mountproc_mnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_DUMP ((u_int32_t)2)
+extern "C" mountlist * mountproc_dump_1(void *, CLIENT *);
+extern "C" mountlist * mountproc_dump_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_UMNT ((u_int32_t)3)
+extern "C" void * mountproc_umnt_1(dirpath *, CLIENT *);
+extern "C" void * mountproc_umnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_UMNTALL ((u_int32_t)4)
+extern "C" void * mountproc_umntall_1(void *, CLIENT *);
+extern "C" void * mountproc_umntall_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORT ((u_int32_t)5)
+extern "C" exports * mountproc_export_1(void *, CLIENT *);
+extern "C" exports * mountproc_export_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORTALL ((u_int32_t)6)
+extern "C" exports * mountproc_exportall_1(void *, CLIENT *);
+extern "C" exports * mountproc_exportall_1_svc(void *, struct svc_req *);
+
+#elif __STDC__
+#define MOUNTPROC_NULL ((u_int32_t)0)
+extern  void * mountproc_null_1(void *, CLIENT *);
+extern  void * mountproc_null_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_MNT ((u_int32_t)1)
+extern  fhstatus * mountproc_mnt_1(dirpath *, CLIENT *);
+extern  fhstatus * mountproc_mnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_DUMP ((u_int32_t)2)
+extern  mountlist * mountproc_dump_1(void *, CLIENT *);
+extern  mountlist * mountproc_dump_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_UMNT ((u_int32_t)3)
+extern  void * mountproc_umnt_1(dirpath *, CLIENT *);
+extern  void * mountproc_umnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_UMNTALL ((u_int32_t)4)
+extern  void * mountproc_umntall_1(void *, CLIENT *);
+extern  void * mountproc_umntall_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORT ((u_int32_t)5)
+extern  exports * mountproc_export_1(void *, CLIENT *);
+extern  exports * mountproc_export_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORTALL ((u_int32_t)6)
+extern  exports * mountproc_exportall_1(void *, CLIENT *);
+extern  exports * mountproc_exportall_1_svc(void *, struct svc_req *);
+
+#else /* Old Style C */ 
+#define MOUNTPROC_NULL ((u_int32_t)0)
+extern  void * mountproc_null_1();
+extern  void * mountproc_null_1_svc();
+#define MOUNTPROC_MNT ((u_int32_t)1)
+extern  fhstatus * mountproc_mnt_1();
+extern  fhstatus * mountproc_mnt_1_svc();
+#define MOUNTPROC_DUMP ((u_int32_t)2)
+extern  mountlist * mountproc_dump_1();
+extern  mountlist * mountproc_dump_1_svc();
+#define MOUNTPROC_UMNT ((u_int32_t)3)
+extern  void * mountproc_umnt_1();
+extern  void * mountproc_umnt_1_svc();
+#define MOUNTPROC_UMNTALL ((u_int32_t)4)
+extern  void * mountproc_umntall_1();
+extern  void * mountproc_umntall_1_svc();
+#define MOUNTPROC_EXPORT ((u_int32_t)5)
+extern  exports * mountproc_export_1();
+extern  exports * mountproc_export_1_svc();
+#define MOUNTPROC_EXPORTALL ((u_int32_t)6)
+extern  exports * mountproc_exportall_1();
+extern  exports * mountproc_exportall_1_svc();
+#endif /* Old Style C */ 
+#define MOUNTVERS_POSIX ((u_int32_t)2)
+
+#ifdef __cplusplus
+extern "C" void * mountproc_null_2(void *, CLIENT *);
+extern "C" void * mountproc_null_2_svc(void *, struct svc_req *);
+extern "C" fhstatus * mountproc_mnt_2(dirpath *, CLIENT *);
+extern "C" fhstatus * mountproc_mnt_2_svc(dirpath *, struct svc_req *);
+extern "C" mountlist * mountproc_dump_2(void *, CLIENT *);
+extern "C" mountlist * mountproc_dump_2_svc(void *, struct svc_req *);
+extern "C" void * mountproc_umnt_2(dirpath *, CLIENT *);
+extern "C" void * mountproc_umnt_2_svc(dirpath *, struct svc_req *);
+extern "C" void * mountproc_umntall_2(void *, CLIENT *);
+extern "C" void * mountproc_umntall_2_svc(void *, struct svc_req *);
+extern "C" exports * mountproc_export_2(void *, CLIENT *);
+extern "C" exports * mountproc_export_2_svc(void *, struct svc_req *);
+extern "C" exports * mountproc_exportall_2(void *, CLIENT *);
+extern "C" exports * mountproc_exportall_2_svc(void *, struct svc_req *);
+#define MOUNTPROC_PATHCONF ((u_int32_t)7)
+extern "C" ppathcnf * mountproc_pathconf_2(dirpath *, CLIENT *);
+extern "C" ppathcnf * mountproc_pathconf_2_svc(dirpath *, struct svc_req *);
+
+#elif __STDC__
+extern  void * mountproc_null_2(void *, CLIENT *);
+extern  void * mountproc_null_2_svc(void *, struct svc_req *);
+extern  fhstatus * mountproc_mnt_2(dirpath *, CLIENT *);
+extern  fhstatus * mountproc_mnt_2_svc(dirpath *, struct svc_req *);
+extern  mountlist * mountproc_dump_2(void *, CLIENT *);
+extern  mountlist * mountproc_dump_2_svc(void *, struct svc_req *);
+extern  void * mountproc_umnt_2(dirpath *, CLIENT *);
+extern  void * mountproc_umnt_2_svc(dirpath *, struct svc_req *);
+extern  void * mountproc_umntall_2(void *, CLIENT *);
+extern  void * mountproc_umntall_2_svc(void *, struct svc_req *);
+extern  exports * mountproc_export_2(void *, CLIENT *);
+extern  exports * mountproc_export_2_svc(void *, struct svc_req *);
+extern  exports * mountproc_exportall_2(void *, CLIENT *);
+extern  exports * mountproc_exportall_2_svc(void *, struct svc_req *);
+#define MOUNTPROC_PATHCONF ((u_int32_t)7)
+extern  ppathcnf * mountproc_pathconf_2(dirpath *, CLIENT *);
+extern  ppathcnf * mountproc_pathconf_2_svc(dirpath *, struct svc_req *);
+
+#else /* Old Style C */ 
+extern  void * mountproc_null_2();
+extern  void * mountproc_null_2_svc();
+extern  fhstatus * mountproc_mnt_2();
+extern  fhstatus * mountproc_mnt_2_svc();
+extern  mountlist * mountproc_dump_2();
+extern  mountlist * mountproc_dump_2_svc();
+extern  void * mountproc_umnt_2();
+extern  void * mountproc_umnt_2_svc();
+extern  void * mountproc_umntall_2();
+extern  void * mountproc_umntall_2_svc();
+extern  exports * mountproc_export_2();
+extern  exports * mountproc_export_2_svc();
+extern  exports * mountproc_exportall_2();
+extern  exports * mountproc_exportall_2_svc();
+#define MOUNTPROC_PATHCONF ((u_int32_t)7)
+extern  ppathcnf * mountproc_pathconf_2();
+extern  ppathcnf * mountproc_pathconf_2_svc();
+#endif /* Old Style C */ 
+#define MOUNTVERS_NFSV3 ((u_int32_t)3)
+
+#ifdef __cplusplus
+#define MOUNTPROC3_NULL ((u_int32_t)0)
+extern "C" void * mountproc3_null_3(void *, CLIENT *);
+extern "C" void * mountproc3_null_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_MNT ((u_int32_t)1)
+extern "C" mountres3 * mountproc3_mnt_3(dirpath *, CLIENT *);
+extern "C" mountres3 * mountproc3_mnt_3_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC3_DUMP ((u_int32_t)2)
+extern "C" mountlist * mountproc3_dump_3(void *, CLIENT *);
+extern "C" mountlist * mountproc3_dump_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_UMNT ((u_int32_t)3)
+extern "C" void * mountproc3_umnt_3(dirpath *, CLIENT *);
+extern "C" void * mountproc3_umnt_3_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC3_UMNTALL ((u_int32_t)4)
+extern "C" void * mountproc3_umntall_3(void *, CLIENT *);
+extern "C" void * mountproc3_umntall_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_EXPORT ((u_int32_t)5)
+extern "C" exports * mountproc3_export_3(void *, CLIENT *);
+extern "C" exports * mountproc3_export_3_svc(void *, struct svc_req *);
+
+#elif __STDC__
+#define MOUNTPROC3_NULL ((u_int32_t)0)
+extern  void * mountproc3_null_3(void *, CLIENT *);
+extern  void * mountproc3_null_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_MNT ((u_int32_t)1)
+extern  mountres3 * mountproc3_mnt_3(dirpath *, CLIENT *);
+extern  mountres3 * mountproc3_mnt_3_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC3_DUMP ((u_int32_t)2)
+extern  mountlist * mountproc3_dump_3(void *, CLIENT *);
+extern  mountlist * mountproc3_dump_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_UMNT ((u_int32_t)3)
+extern  void * mountproc3_umnt_3(dirpath *, CLIENT *);
+extern  void * mountproc3_umnt_3_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC3_UMNTALL ((u_int32_t)4)
+extern  void * mountproc3_umntall_3(void *, CLIENT *);
+extern  void * mountproc3_umntall_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_EXPORT ((u_int32_t)5)
+extern  exports * mountproc3_export_3(void *, CLIENT *);
+extern  exports * mountproc3_export_3_svc(void *, struct svc_req *);
+
+#else /* Old Style C */ 
+#define MOUNTPROC3_NULL ((u_int32_t)0)
+extern  void * mountproc3_null_3();
+extern  void * mountproc3_null_3_svc();
+#define MOUNTPROC3_MNT ((u_int32_t)1)
+extern  mountres3 * mountproc3_mnt_3();
+extern  mountres3 * mountproc3_mnt_3_svc();
+#define MOUNTPROC3_DUMP ((u_int32_t)2)
+extern  mountlist * mountproc3_dump_3();
+extern  mountlist * mountproc3_dump_3_svc();
+#define MOUNTPROC3_UMNT ((u_int32_t)3)
+extern  void * mountproc3_umnt_3();
+extern  void * mountproc3_umnt_3_svc();
+#define MOUNTPROC3_UMNTALL ((u_int32_t)4)
+extern  void * mountproc3_umntall_3();
+extern  void * mountproc3_umntall_3_svc();
+#define MOUNTPROC3_EXPORT ((u_int32_t)5)
+extern  exports * mountproc3_export_3();
+extern  exports * mountproc3_export_3_svc();
+#endif /* Old Style C */ 
+
+#endif /* !_MOUNT_H_RPCGEN */
diff -urN nfs-utils-1.0.7.old/support/export/mount_clnt.c nfs-utils-1.0.7/support/export/mount_clnt.c
--- nfs-utils-1.0.7.old/support/export/mount_clnt.c	1970-01-01 01:00:00.000000000 +0100
+++ nfs-utils-1.0.7/support/export/mount_clnt.c	2006-03-24 15:39:43.000000000 +0100
@@ -0,0 +1,337 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "mount.h"
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user or with the express written consent of
+ * Sun Microsystems, Inc.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+/*
+ * Copyright (c) 1985, 1990 by Sun Microsystems, Inc.
+ */
+
+/* from @(#)mount.x	1.3 91/03/11 TIRPC 1.0 */
+
+/* Default timeout can be changed using clnt_control() */
+static struct timeval TIMEOUT = { 25, 0 };
+
+void *
+mountproc_null_1(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_NULL, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+fhstatus *
+mountproc_mnt_1(argp, clnt)
+	dirpath *argp;
+	CLIENT *clnt;
+{
+	static fhstatus clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_MNT, (xdrproc_t) xdr_dirpath, (caddr_t) argp, (xdrproc_t) xdr_fhstatus, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+mountlist *
+mountproc_dump_1(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static mountlist clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_DUMP, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_mountlist, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+void *
+mountproc_umnt_1(argp, clnt)
+	dirpath *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_UMNT, (xdrproc_t) xdr_dirpath, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+void *
+mountproc_umntall_1(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_UMNTALL, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+exports *
+mountproc_export_1(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static exports clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_EXPORT, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_exports, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+exports *
+mountproc_exportall_1(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static exports clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_EXPORTALL, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_exports, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+void *
+mountproc_null_2(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_NULL, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+fhstatus *
+mountproc_mnt_2(argp, clnt)
+	dirpath *argp;
+	CLIENT *clnt;
+{
+	static fhstatus clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_MNT, (xdrproc_t) xdr_dirpath, (caddr_t) argp, (xdrproc_t) xdr_fhstatus, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+mountlist *
+mountproc_dump_2(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static mountlist clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_DUMP, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_mountlist, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+void *
+mountproc_umnt_2(argp, clnt)
+	dirpath *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_UMNT, (xdrproc_t) xdr_dirpath, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+void *
+mountproc_umntall_2(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_UMNTALL, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+exports *
+mountproc_export_2(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static exports clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_EXPORT, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_exports, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+exports *
+mountproc_exportall_2(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static exports clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_EXPORTALL, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_exports, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+ppathcnf *
+mountproc_pathconf_2(argp, clnt)
+	dirpath *argp;
+	CLIENT *clnt;
+{
+	static ppathcnf clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC_PATHCONF, (xdrproc_t) xdr_dirpath, (caddr_t) argp, (xdrproc_t) xdr_ppathcnf, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+void *
+mountproc3_null_3(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC3_NULL, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+mountres3 *
+mountproc3_mnt_3(argp, clnt)
+	dirpath *argp;
+	CLIENT *clnt;
+{
+	static mountres3 clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC3_MNT, (xdrproc_t) xdr_dirpath, (caddr_t) argp, (xdrproc_t) xdr_mountres3, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+mountlist *
+mountproc3_dump_3(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static mountlist clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC3_DUMP, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_mountlist, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+void *
+mountproc3_umnt_3(argp, clnt)
+	dirpath *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC3_UMNT, (xdrproc_t) xdr_dirpath, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+void *
+mountproc3_umntall_3(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC3_UMNTALL, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+exports *
+mountproc3_export_3(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static exports clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, MOUNTPROC3_EXPORT, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_exports, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
diff -urN nfs-utils-1.0.7.old/support/export/mount_xdr.c nfs-utils-1.0.7/support/export/mount_xdr.c
--- nfs-utils-1.0.7.old/support/export/mount_xdr.c	1970-01-01 01:00:00.000000000 +0100
+++ nfs-utils-1.0.7/support/export/mount_xdr.c	2006-03-24 15:39:43.000000000 +0100
@@ -0,0 +1,421 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "mount.h"
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user or with the express written consent of
+ * Sun Microsystems, Inc.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+/*
+ * Copyright (c) 1985, 1990 by Sun Microsystems, Inc.
+ */
+
+/* from @(#)mount.x	1.3 91/03/11 TIRPC 1.0 */
+
+bool_t
+xdr_fhandle(xdrs, objp)
+	XDR *xdrs;
+	fhandle objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_opaque(xdrs, objp, FHSIZE)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_fhstatus(xdrs, objp)
+	XDR *xdrs;
+	fhstatus *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_u_int(xdrs, &objp->fhs_status)) {
+		 return (FALSE);
+	 }
+	switch (objp->fhs_status) {
+	case 0:
+		 if (!xdr_fhandle(xdrs, objp->fhstatus_u.fhs_fhandle)) {
+			 return (FALSE);
+		 }
+		break;
+	default:
+		break;
+	}
+	return (TRUE);
+}
+
+bool_t
+xdr_dirpath(xdrs, objp)
+	XDR *xdrs;
+	dirpath *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_string(xdrs, objp, MNTPATHLEN)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_name(xdrs, objp)
+	XDR *xdrs;
+	name *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_string(xdrs, objp, MNTNAMLEN)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_mountlist(xdrs, objp)
+	XDR *xdrs;
+	mountlist *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_pointer(xdrs, (char **)objp, sizeof(struct mountbody), (xdrproc_t)xdr_mountbody)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_mountbody(xdrs, objp)
+	XDR *xdrs;
+	mountbody *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_name(xdrs, &objp->ml_hostname)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_dirpath(xdrs, &objp->ml_directory)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_mountlist(xdrs, &objp->ml_next)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_groups(xdrs, objp)
+	XDR *xdrs;
+	groups *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_pointer(xdrs, (char **)objp, sizeof(struct groupnode), (xdrproc_t)xdr_groupnode)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_groupnode(xdrs, objp)
+	XDR *xdrs;
+	groupnode *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_name(xdrs, &objp->gr_name)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_groups(xdrs, &objp->gr_next)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_exports(xdrs, objp)
+	XDR *xdrs;
+	exports *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_pointer(xdrs, (char **)objp, sizeof(struct exportnode), (xdrproc_t)xdr_exportnode)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_exportnode(xdrs, objp)
+	XDR *xdrs;
+	exportnode *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_dirpath(xdrs, &objp->ex_dir)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_groups(xdrs, &objp->ex_groups)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_exports(xdrs, &objp->ex_next)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_ppathcnf(xdrs, objp)
+	XDR *xdrs;
+	ppathcnf *objp;
+{
+
+	 register int32_t *buf;
+
+	 int i;
+
+	 if (xdrs->x_op == XDR_ENCODE) {
+	 buf = XDR_INLINE(xdrs,6 * BYTES_PER_XDR_UNIT);
+	   if (buf == NULL) {
+		 if (!xdr_int(xdrs, &objp->pc_link_max)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_max_canon)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_max_input)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_name_max)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_path_max)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_pipe_buf)) {
+			 return (FALSE);
+		 }
+
+	  }
+	  else {
+		 IXDR_PUT_INT32(buf,objp->pc_link_max);
+		 IXDR_PUT_SHORT(buf,objp->pc_max_canon);
+		 IXDR_PUT_SHORT(buf,objp->pc_max_input);
+		 IXDR_PUT_SHORT(buf,objp->pc_name_max);
+		 IXDR_PUT_SHORT(buf,objp->pc_path_max);
+		 IXDR_PUT_SHORT(buf,objp->pc_pipe_buf);
+	  }
+	 if (!xdr_u_char(xdrs, &objp->pc_vdisable)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_char(xdrs, &objp->pc_xxx)) {
+		 return (FALSE);
+	 }
+		buf = XDR_INLINE(xdrs,   2  * BYTES_PER_XDR_UNIT);
+		if (buf == NULL) {
+		 if (!xdr_vector(xdrs, (char *)objp->pc_mask, 2, sizeof(short), (xdrproc_t)xdr_short)) {
+			 return (FALSE);
+		 }
+
+	  }
+	  else {
+		{ register short *genp; 
+		  for ( i = 0,genp=objp->pc_mask;
+ 			i < 2; i++){
+				 IXDR_PUT_SHORT(buf,*genp++);
+		   }
+		 };
+	  }
+
+ 	 return (TRUE);
+	} else if (xdrs->x_op == XDR_DECODE) {
+	 buf = XDR_INLINE(xdrs,6 * BYTES_PER_XDR_UNIT);
+	   if (buf == NULL) {
+		 if (!xdr_int(xdrs, &objp->pc_link_max)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_max_canon)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_max_input)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_name_max)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_path_max)) {
+			 return (FALSE);
+		 }
+		 if (!xdr_short(xdrs, &objp->pc_pipe_buf)) {
+			 return (FALSE);
+		 }
+
+	  }
+	  else {
+		 objp->pc_link_max = IXDR_GET_INT32(buf);
+		 objp->pc_max_canon = IXDR_GET_SHORT(buf);
+		 objp->pc_max_input = IXDR_GET_SHORT(buf);
+		 objp->pc_name_max = IXDR_GET_SHORT(buf);
+		 objp->pc_path_max = IXDR_GET_SHORT(buf);
+		 objp->pc_pipe_buf = IXDR_GET_SHORT(buf);
+	  }
+	 if (!xdr_u_char(xdrs, &objp->pc_vdisable)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_char(xdrs, &objp->pc_xxx)) {
+		 return (FALSE);
+	 }
+		buf = XDR_INLINE(xdrs,   2  * BYTES_PER_XDR_UNIT);
+		if (buf == NULL) {
+		 if (!xdr_vector(xdrs, (char *)objp->pc_mask, 2, sizeof(short), (xdrproc_t)xdr_short)) {
+			 return (FALSE);
+		 }
+
+	  }
+	  else {
+		{ register short *genp; 
+		  for ( i = 0,genp=objp->pc_mask;
+ 			i < 2; i++){
+				 *genp++ = IXDR_GET_SHORT(buf);
+		   }
+		 };
+	  }
+	 return(TRUE);
+	}
+
+	 if (!xdr_int(xdrs, &objp->pc_link_max)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_short(xdrs, &objp->pc_max_canon)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_short(xdrs, &objp->pc_max_input)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_short(xdrs, &objp->pc_name_max)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_short(xdrs, &objp->pc_path_max)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_short(xdrs, &objp->pc_pipe_buf)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_u_char(xdrs, &objp->pc_vdisable)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_char(xdrs, &objp->pc_xxx)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_vector(xdrs, (char *)objp->pc_mask, 2, sizeof(short), (xdrproc_t)xdr_short)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_fhandle3(xdrs, objp)
+	XDR *xdrs;
+	fhandle3 *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_bytes(xdrs, (char **)&objp->fhandle3_val, (u_int *)&objp->fhandle3_len, FHSIZE3)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_mountstat3(xdrs, objp)
+	XDR *xdrs;
+	mountstat3 *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_mountres3_ok(xdrs, objp)
+	XDR *xdrs;
+	mountres3_ok *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_fhandle3(xdrs, &objp->fhandle)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_array(xdrs, (char **)&objp->auth_flavors.auth_flavors_val, (u_int *)&objp->auth_flavors.auth_flavors_len, ~0, sizeof(int), (xdrproc_t)xdr_int)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_mountres3(xdrs, objp)
+	XDR *xdrs;
+	mountres3 *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_mountstat3(xdrs, &objp->fhs_status)) {
+		 return (FALSE);
+	 }
+	switch (objp->fhs_status) {
+	case MNT_OK:
+		 if (!xdr_mountres3_ok(xdrs, &objp->mountres3_u.mountinfo)) {
+			 return (FALSE);
+		 }
+		break;
+	default:
+		break;
+	}
+	return (TRUE);
+}
diff -urN nfs-utils-1.0.7.old/support/include/mount.h nfs-utils-1.0.7/support/include/mount.h
--- nfs-utils-1.0.7.old/support/include/mount.h	1970-01-01 01:00:00.000000000 +0100
+++ nfs-utils-1.0.7/support/include/mount.h	2006-03-24 15:39:43.000000000 +0100
@@ -0,0 +1,469 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _MOUNT_H_RPCGEN
+#define _MOUNT_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+#ifndef IXDR_GET_INT32
+#define IXDR_GET_INT32(buf) IXDR_GET_LONG((buf))
+#endif
+#ifndef IXDR_PUT_INT32
+#define IXDR_PUT_INT32(buf, v) IXDR_PUT_LONG((buf), (v))
+#endif
+#ifndef IXDR_GET_U_INT32
+#define IXDR_GET_U_INT32(buf) IXDR_GET_U_LONG((buf))
+#endif
+#ifndef IXDR_PUT_U_INT32
+#define IXDR_PUT_U_INT32(buf, v) IXDR_PUT_U_LONG((buf), (v))
+#endif
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user or with the express written consent of
+ * Sun Microsystems, Inc.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+/*
+ * Copyright (c) 1985, 1990 by Sun Microsystems, Inc.
+ */
+
+/* from @(#)mount.x	1.3 91/03/11 TIRPC 1.0 */
+#ifndef _rpcsvc_mount_h
+#define _rpcsvc_mount_h
+#include <memory.h>
+#define MNTPATHLEN 1024
+#define MNTNAMLEN 255
+#define FHSIZE 32
+
+typedef char fhandle[FHSIZE];
+#ifdef __cplusplus 
+extern "C" bool_t xdr_fhandle(XDR *, fhandle);
+#elif __STDC__ 
+extern  bool_t xdr_fhandle(XDR *, fhandle);
+#else /* Old Style C */ 
+bool_t xdr_fhandle();
+#endif /* Old Style C */ 
+
+
+struct fhstatus {
+	u_int fhs_status;
+	union {
+		fhandle fhs_fhandle;
+	} fhstatus_u;
+};
+typedef struct fhstatus fhstatus;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_fhstatus(XDR *, fhstatus*);
+#elif __STDC__ 
+extern  bool_t xdr_fhstatus(XDR *, fhstatus*);
+#else /* Old Style C */ 
+bool_t xdr_fhstatus();
+#endif /* Old Style C */ 
+
+
+typedef char *dirpath;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_dirpath(XDR *, dirpath*);
+#elif __STDC__ 
+extern  bool_t xdr_dirpath(XDR *, dirpath*);
+#else /* Old Style C */ 
+bool_t xdr_dirpath();
+#endif /* Old Style C */ 
+
+
+typedef char *name;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_name(XDR *, name*);
+#elif __STDC__ 
+extern  bool_t xdr_name(XDR *, name*);
+#else /* Old Style C */ 
+bool_t xdr_name();
+#endif /* Old Style C */ 
+
+
+typedef struct mountbody *mountlist;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountlist(XDR *, mountlist*);
+#elif __STDC__ 
+extern  bool_t xdr_mountlist(XDR *, mountlist*);
+#else /* Old Style C */ 
+bool_t xdr_mountlist();
+#endif /* Old Style C */ 
+
+
+struct mountbody {
+	name ml_hostname;
+	dirpath ml_directory;
+	mountlist ml_next;
+};
+typedef struct mountbody mountbody;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountbody(XDR *, mountbody*);
+#elif __STDC__ 
+extern  bool_t xdr_mountbody(XDR *, mountbody*);
+#else /* Old Style C */ 
+bool_t xdr_mountbody();
+#endif /* Old Style C */ 
+
+
+typedef struct groupnode *groups;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_groups(XDR *, groups*);
+#elif __STDC__ 
+extern  bool_t xdr_groups(XDR *, groups*);
+#else /* Old Style C */ 
+bool_t xdr_groups();
+#endif /* Old Style C */ 
+
+
+struct groupnode {
+	name gr_name;
+	groups gr_next;
+};
+typedef struct groupnode groupnode;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_groupnode(XDR *, groupnode*);
+#elif __STDC__ 
+extern  bool_t xdr_groupnode(XDR *, groupnode*);
+#else /* Old Style C */ 
+bool_t xdr_groupnode();
+#endif /* Old Style C */ 
+
+
+typedef struct exportnode *exports;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_exports(XDR *, exports*);
+#elif __STDC__ 
+extern  bool_t xdr_exports(XDR *, exports*);
+#else /* Old Style C */ 
+bool_t xdr_exports();
+#endif /* Old Style C */ 
+
+
+struct exportnode {
+	dirpath ex_dir;
+	groups ex_groups;
+	exports ex_next;
+};
+typedef struct exportnode exportnode;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_exportnode(XDR *, exportnode*);
+#elif __STDC__ 
+extern  bool_t xdr_exportnode(XDR *, exportnode*);
+#else /* Old Style C */ 
+bool_t xdr_exportnode();
+#endif /* Old Style C */ 
+
+
+struct ppathcnf {
+	int pc_link_max;
+	short pc_max_canon;
+	short pc_max_input;
+	short pc_name_max;
+	short pc_path_max;
+	short pc_pipe_buf;
+	u_char pc_vdisable;
+	char pc_xxx;
+	short pc_mask[2];
+};
+typedef struct ppathcnf ppathcnf;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_ppathcnf(XDR *, ppathcnf*);
+#elif __STDC__ 
+extern  bool_t xdr_ppathcnf(XDR *, ppathcnf*);
+#else /* Old Style C */ 
+bool_t xdr_ppathcnf();
+#endif /* Old Style C */ 
+
+#define FHSIZE3 64
+
+typedef struct {
+	u_int fhandle3_len;
+	char *fhandle3_val;
+} fhandle3;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_fhandle3(XDR *, fhandle3*);
+#elif __STDC__ 
+extern  bool_t xdr_fhandle3(XDR *, fhandle3*);
+#else /* Old Style C */ 
+bool_t xdr_fhandle3();
+#endif /* Old Style C */ 
+
+
+enum mountstat3 {
+	MNT_OK = 0,
+	MNT3ERR_PERM = 1,
+	MNT3ERR_NOENT = 2,
+	MNT3ERR_IO = 5,
+	MNT3ERR_ACCES = 13,
+	MNT3ERR_NOTDIR = 20,
+	MNT3ERR_INVAL = 22,
+	MNT3ERR_NAMETOOLONG = 63,
+	MNT3ERR_NOTSUPP = 10004,
+	MNT3ERR_SERVERFAULT = 10006,
+};
+typedef enum mountstat3 mountstat3;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountstat3(XDR *, mountstat3*);
+#elif __STDC__ 
+extern  bool_t xdr_mountstat3(XDR *, mountstat3*);
+#else /* Old Style C */ 
+bool_t xdr_mountstat3();
+#endif /* Old Style C */ 
+
+
+struct mountres3_ok {
+	fhandle3 fhandle;
+	struct {
+		u_int auth_flavors_len;
+		int *auth_flavors_val;
+	} auth_flavors;
+};
+typedef struct mountres3_ok mountres3_ok;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountres3_ok(XDR *, mountres3_ok*);
+#elif __STDC__ 
+extern  bool_t xdr_mountres3_ok(XDR *, mountres3_ok*);
+#else /* Old Style C */ 
+bool_t xdr_mountres3_ok();
+#endif /* Old Style C */ 
+
+
+struct mountres3 {
+	mountstat3 fhs_status;
+	union {
+		mountres3_ok mountinfo;
+	} mountres3_u;
+};
+typedef struct mountres3 mountres3;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mountres3(XDR *, mountres3*);
+#elif __STDC__ 
+extern  bool_t xdr_mountres3(XDR *, mountres3*);
+#else /* Old Style C */ 
+bool_t xdr_mountres3();
+#endif /* Old Style C */ 
+
+#endif /*!_rpcsvc_mount_h*/
+
+#define MOUNTPROG ((u_int32_t)100005)
+#define MOUNTVERS ((u_int32_t)1)
+
+#ifdef __cplusplus
+#define MOUNTPROC_NULL ((u_int32_t)0)
+extern "C" void * mountproc_null_1(void *, CLIENT *);
+extern "C" void * mountproc_null_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_MNT ((u_int32_t)1)
+extern "C" fhstatus * mountproc_mnt_1(dirpath *, CLIENT *);
+extern "C" fhstatus * mountproc_mnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_DUMP ((u_int32_t)2)
+extern "C" mountlist * mountproc_dump_1(void *, CLIENT *);
+extern "C" mountlist * mountproc_dump_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_UMNT ((u_int32_t)3)
+extern "C" void * mountproc_umnt_1(dirpath *, CLIENT *);
+extern "C" void * mountproc_umnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_UMNTALL ((u_int32_t)4)
+extern "C" void * mountproc_umntall_1(void *, CLIENT *);
+extern "C" void * mountproc_umntall_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORT ((u_int32_t)5)
+extern "C" exports * mountproc_export_1(void *, CLIENT *);
+extern "C" exports * mountproc_export_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORTALL ((u_int32_t)6)
+extern "C" exports * mountproc_exportall_1(void *, CLIENT *);
+extern "C" exports * mountproc_exportall_1_svc(void *, struct svc_req *);
+
+#elif __STDC__
+#define MOUNTPROC_NULL ((u_int32_t)0)
+extern  void * mountproc_null_1(void *, CLIENT *);
+extern  void * mountproc_null_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_MNT ((u_int32_t)1)
+extern  fhstatus * mountproc_mnt_1(dirpath *, CLIENT *);
+extern  fhstatus * mountproc_mnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_DUMP ((u_int32_t)2)
+extern  mountlist * mountproc_dump_1(void *, CLIENT *);
+extern  mountlist * mountproc_dump_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_UMNT ((u_int32_t)3)
+extern  void * mountproc_umnt_1(dirpath *, CLIENT *);
+extern  void * mountproc_umnt_1_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC_UMNTALL ((u_int32_t)4)
+extern  void * mountproc_umntall_1(void *, CLIENT *);
+extern  void * mountproc_umntall_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORT ((u_int32_t)5)
+extern  exports * mountproc_export_1(void *, CLIENT *);
+extern  exports * mountproc_export_1_svc(void *, struct svc_req *);
+#define MOUNTPROC_EXPORTALL ((u_int32_t)6)
+extern  exports * mountproc_exportall_1(void *, CLIENT *);
+extern  exports * mountproc_exportall_1_svc(void *, struct svc_req *);
+
+#else /* Old Style C */ 
+#define MOUNTPROC_NULL ((u_int32_t)0)
+extern  void * mountproc_null_1();
+extern  void * mountproc_null_1_svc();
+#define MOUNTPROC_MNT ((u_int32_t)1)
+extern  fhstatus * mountproc_mnt_1();
+extern  fhstatus * mountproc_mnt_1_svc();
+#define MOUNTPROC_DUMP ((u_int32_t)2)
+extern  mountlist * mountproc_dump_1();
+extern  mountlist * mountproc_dump_1_svc();
+#define MOUNTPROC_UMNT ((u_int32_t)3)
+extern  void * mountproc_umnt_1();
+extern  void * mountproc_umnt_1_svc();
+#define MOUNTPROC_UMNTALL ((u_int32_t)4)
+extern  void * mountproc_umntall_1();
+extern  void * mountproc_umntall_1_svc();
+#define MOUNTPROC_EXPORT ((u_int32_t)5)
+extern  exports * mountproc_export_1();
+extern  exports * mountproc_export_1_svc();
+#define MOUNTPROC_EXPORTALL ((u_int32_t)6)
+extern  exports * mountproc_exportall_1();
+extern  exports * mountproc_exportall_1_svc();
+#endif /* Old Style C */ 
+#define MOUNTVERS_POSIX ((u_int32_t)2)
+
+#ifdef __cplusplus
+extern "C" void * mountproc_null_2(void *, CLIENT *);
+extern "C" void * mountproc_null_2_svc(void *, struct svc_req *);
+extern "C" fhstatus * mountproc_mnt_2(dirpath *, CLIENT *);
+extern "C" fhstatus * mountproc_mnt_2_svc(dirpath *, struct svc_req *);
+extern "C" mountlist * mountproc_dump_2(void *, CLIENT *);
+extern "C" mountlist * mountproc_dump_2_svc(void *, struct svc_req *);
+extern "C" void * mountproc_umnt_2(dirpath *, CLIENT *);
+extern "C" void * mountproc_umnt_2_svc(dirpath *, struct svc_req *);
+extern "C" void * mountproc_umntall_2(void *, CLIENT *);
+extern "C" void * mountproc_umntall_2_svc(void *, struct svc_req *);
+extern "C" exports * mountproc_export_2(void *, CLIENT *);
+extern "C" exports * mountproc_export_2_svc(void *, struct svc_req *);
+extern "C" exports * mountproc_exportall_2(void *, CLIENT *);
+extern "C" exports * mountproc_exportall_2_svc(void *, struct svc_req *);
+#define MOUNTPROC_PATHCONF ((u_int32_t)7)
+extern "C" ppathcnf * mountproc_pathconf_2(dirpath *, CLIENT *);
+extern "C" ppathcnf * mountproc_pathconf_2_svc(dirpath *, struct svc_req *);
+
+#elif __STDC__
+extern  void * mountproc_null_2(void *, CLIENT *);
+extern  void * mountproc_null_2_svc(void *, struct svc_req *);
+extern  fhstatus * mountproc_mnt_2(dirpath *, CLIENT *);
+extern  fhstatus * mountproc_mnt_2_svc(dirpath *, struct svc_req *);
+extern  mountlist * mountproc_dump_2(void *, CLIENT *);
+extern  mountlist * mountproc_dump_2_svc(void *, struct svc_req *);
+extern  void * mountproc_umnt_2(dirpath *, CLIENT *);
+extern  void * mountproc_umnt_2_svc(dirpath *, struct svc_req *);
+extern  void * mountproc_umntall_2(void *, CLIENT *);
+extern  void * mountproc_umntall_2_svc(void *, struct svc_req *);
+extern  exports * mountproc_export_2(void *, CLIENT *);
+extern  exports * mountproc_export_2_svc(void *, struct svc_req *);
+extern  exports * mountproc_exportall_2(void *, CLIENT *);
+extern  exports * mountproc_exportall_2_svc(void *, struct svc_req *);
+#define MOUNTPROC_PATHCONF ((u_int32_t)7)
+extern  ppathcnf * mountproc_pathconf_2(dirpath *, CLIENT *);
+extern  ppathcnf * mountproc_pathconf_2_svc(dirpath *, struct svc_req *);
+
+#else /* Old Style C */ 
+extern  void * mountproc_null_2();
+extern  void * mountproc_null_2_svc();
+extern  fhstatus * mountproc_mnt_2();
+extern  fhstatus * mountproc_mnt_2_svc();
+extern  mountlist * mountproc_dump_2();
+extern  mountlist * mountproc_dump_2_svc();
+extern  void * mountproc_umnt_2();
+extern  void * mountproc_umnt_2_svc();
+extern  void * mountproc_umntall_2();
+extern  void * mountproc_umntall_2_svc();
+extern  exports * mountproc_export_2();
+extern  exports * mountproc_export_2_svc();
+extern  exports * mountproc_exportall_2();
+extern  exports * mountproc_exportall_2_svc();
+#define MOUNTPROC_PATHCONF ((u_int32_t)7)
+extern  ppathcnf * mountproc_pathconf_2();
+extern  ppathcnf * mountproc_pathconf_2_svc();
+#endif /* Old Style C */ 
+#define MOUNTVERS_NFSV3 ((u_int32_t)3)
+
+#ifdef __cplusplus
+#define MOUNTPROC3_NULL ((u_int32_t)0)
+extern "C" void * mountproc3_null_3(void *, CLIENT *);
+extern "C" void * mountproc3_null_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_MNT ((u_int32_t)1)
+extern "C" mountres3 * mountproc3_mnt_3(dirpath *, CLIENT *);
+extern "C" mountres3 * mountproc3_mnt_3_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC3_DUMP ((u_int32_t)2)
+extern "C" mountlist * mountproc3_dump_3(void *, CLIENT *);
+extern "C" mountlist * mountproc3_dump_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_UMNT ((u_int32_t)3)
+extern "C" void * mountproc3_umnt_3(dirpath *, CLIENT *);
+extern "C" void * mountproc3_umnt_3_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC3_UMNTALL ((u_int32_t)4)
+extern "C" void * mountproc3_umntall_3(void *, CLIENT *);
+extern "C" void * mountproc3_umntall_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_EXPORT ((u_int32_t)5)
+extern "C" exports * mountproc3_export_3(void *, CLIENT *);
+extern "C" exports * mountproc3_export_3_svc(void *, struct svc_req *);
+
+#elif __STDC__
+#define MOUNTPROC3_NULL ((u_int32_t)0)
+extern  void * mountproc3_null_3(void *, CLIENT *);
+extern  void * mountproc3_null_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_MNT ((u_int32_t)1)
+extern  mountres3 * mountproc3_mnt_3(dirpath *, CLIENT *);
+extern  mountres3 * mountproc3_mnt_3_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC3_DUMP ((u_int32_t)2)
+extern  mountlist * mountproc3_dump_3(void *, CLIENT *);
+extern  mountlist * mountproc3_dump_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_UMNT ((u_int32_t)3)
+extern  void * mountproc3_umnt_3(dirpath *, CLIENT *);
+extern  void * mountproc3_umnt_3_svc(dirpath *, struct svc_req *);
+#define MOUNTPROC3_UMNTALL ((u_int32_t)4)
+extern  void * mountproc3_umntall_3(void *, CLIENT *);
+extern  void * mountproc3_umntall_3_svc(void *, struct svc_req *);
+#define MOUNTPROC3_EXPORT ((u_int32_t)5)
+extern  exports * mountproc3_export_3(void *, CLIENT *);
+extern  exports * mountproc3_export_3_svc(void *, struct svc_req *);
+
+#else /* Old Style C */ 
+#define MOUNTPROC3_NULL ((u_int32_t)0)
+extern  void * mountproc3_null_3();
+extern  void * mountproc3_null_3_svc();
+#define MOUNTPROC3_MNT ((u_int32_t)1)
+extern  mountres3 * mountproc3_mnt_3();
+extern  mountres3 * mountproc3_mnt_3_svc();
+#define MOUNTPROC3_DUMP ((u_int32_t)2)
+extern  mountlist * mountproc3_dump_3();
+extern  mountlist * mountproc3_dump_3_svc();
+#define MOUNTPROC3_UMNT ((u_int32_t)3)
+extern  void * mountproc3_umnt_3();
+extern  void * mountproc3_umnt_3_svc();
+#define MOUNTPROC3_UMNTALL ((u_int32_t)4)
+extern  void * mountproc3_umntall_3();
+extern  void * mountproc3_umntall_3_svc();
+#define MOUNTPROC3_EXPORT ((u_int32_t)5)
+extern  exports * mountproc3_export_3();
+extern  exports * mountproc3_export_3_svc();
+#endif /* Old Style C */ 
+
+#endif /* !_MOUNT_H_RPCGEN */
diff -urN nfs-utils-1.0.7.old/utils/statd/sm_inter.h nfs-utils-1.0.7/utils/statd/sm_inter.h
--- nfs-utils-1.0.7.old/utils/statd/sm_inter.h	1970-01-01 01:00:00.000000000 +0100
+++ nfs-utils-1.0.7/utils/statd/sm_inter.h	2006-03-24 15:39:44.000000000 +0100
@@ -0,0 +1,218 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _SM_INTER_H_RPCGEN
+#define _SM_INTER_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+#ifndef IXDR_GET_INT32
+#define IXDR_GET_INT32(buf) IXDR_GET_LONG((buf))
+#endif
+#ifndef IXDR_PUT_INT32
+#define IXDR_PUT_INT32(buf, v) IXDR_PUT_LONG((buf), (v))
+#endif
+#ifndef IXDR_GET_U_INT32
+#define IXDR_GET_U_INT32(buf) IXDR_GET_U_LONG((buf))
+#endif
+#ifndef IXDR_PUT_U_INT32
+#define IXDR_PUT_U_INT32(buf, v) IXDR_PUT_U_LONG((buf), (v))
+#endif
+#define SM_MAXSTRLEN 1024
+#define SM_PRIV_SIZE 16
+
+struct sm_name {
+	char *mon_name;
+};
+typedef struct sm_name sm_name;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_sm_name(XDR *, sm_name*);
+#elif __STDC__ 
+extern  bool_t xdr_sm_name(XDR *, sm_name*);
+#else /* Old Style C */ 
+bool_t xdr_sm_name();
+#endif /* Old Style C */ 
+
+
+struct my_id {
+	char *my_name;
+	int my_prog;
+	int my_vers;
+	int my_proc;
+};
+typedef struct my_id my_id;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_my_id(XDR *, my_id*);
+#elif __STDC__ 
+extern  bool_t xdr_my_id(XDR *, my_id*);
+#else /* Old Style C */ 
+bool_t xdr_my_id();
+#endif /* Old Style C */ 
+
+
+struct mon_id {
+	char *mon_name;
+	struct my_id my_id;
+};
+typedef struct mon_id mon_id;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mon_id(XDR *, mon_id*);
+#elif __STDC__ 
+extern  bool_t xdr_mon_id(XDR *, mon_id*);
+#else /* Old Style C */ 
+bool_t xdr_mon_id();
+#endif /* Old Style C */ 
+
+
+struct mon {
+	struct mon_id mon_id;
+	char priv[SM_PRIV_SIZE];
+};
+typedef struct mon mon;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_mon(XDR *, mon*);
+#elif __STDC__ 
+extern  bool_t xdr_mon(XDR *, mon*);
+#else /* Old Style C */ 
+bool_t xdr_mon();
+#endif /* Old Style C */ 
+
+
+struct stat_chge {
+	char *mon_name;
+	int state;
+};
+typedef struct stat_chge stat_chge;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_stat_chge(XDR *, stat_chge*);
+#elif __STDC__ 
+extern  bool_t xdr_stat_chge(XDR *, stat_chge*);
+#else /* Old Style C */ 
+bool_t xdr_stat_chge();
+#endif /* Old Style C */ 
+
+
+struct sm_stat {
+	int state;
+};
+typedef struct sm_stat sm_stat;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_sm_stat(XDR *, sm_stat*);
+#elif __STDC__ 
+extern  bool_t xdr_sm_stat(XDR *, sm_stat*);
+#else /* Old Style C */ 
+bool_t xdr_sm_stat();
+#endif /* Old Style C */ 
+
+
+enum res {
+	stat_succ = 0,
+	stat_fail = 1,
+};
+typedef enum res res;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_res(XDR *, res*);
+#elif __STDC__ 
+extern  bool_t xdr_res(XDR *, res*);
+#else /* Old Style C */ 
+bool_t xdr_res();
+#endif /* Old Style C */ 
+
+
+struct sm_stat_res {
+	res res_stat;
+	int state;
+};
+typedef struct sm_stat_res sm_stat_res;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_sm_stat_res(XDR *, sm_stat_res*);
+#elif __STDC__ 
+extern  bool_t xdr_sm_stat_res(XDR *, sm_stat_res*);
+#else /* Old Style C */ 
+bool_t xdr_sm_stat_res();
+#endif /* Old Style C */ 
+
+
+struct status {
+	char *mon_name;
+	int state;
+	char priv[SM_PRIV_SIZE];
+};
+typedef struct status status;
+#ifdef __cplusplus 
+extern "C" bool_t xdr_status(XDR *, status*);
+#elif __STDC__ 
+extern  bool_t xdr_status(XDR *, status*);
+#else /* Old Style C */ 
+bool_t xdr_status();
+#endif /* Old Style C */ 
+
+#define SM_INTER_X
+
+#define SM_PROG ((u_int32_t)100024)
+#define SM_VERS ((u_int32_t)1)
+
+#ifdef __cplusplus
+#define SM_STAT ((u_int32_t)1)
+extern "C" struct sm_stat_res * sm_stat_1(struct sm_name *, CLIENT *);
+extern "C" struct sm_stat_res * sm_stat_1_svc(struct sm_name *, struct svc_req *);
+#define SM_MON ((u_int32_t)2)
+extern "C" struct sm_stat_res * sm_mon_1(struct mon *, CLIENT *);
+extern "C" struct sm_stat_res * sm_mon_1_svc(struct mon *, struct svc_req *);
+#define SM_UNMON ((u_int32_t)3)
+extern "C" struct sm_stat * sm_unmon_1(struct mon_id *, CLIENT *);
+extern "C" struct sm_stat * sm_unmon_1_svc(struct mon_id *, struct svc_req *);
+#define SM_UNMON_ALL ((u_int32_t)4)
+extern "C" struct sm_stat * sm_unmon_all_1(struct my_id *, CLIENT *);
+extern "C" struct sm_stat * sm_unmon_all_1_svc(struct my_id *, struct svc_req *);
+#define SM_SIMU_CRASH ((u_int32_t)5)
+extern "C" void * sm_simu_crash_1(void *, CLIENT *);
+extern "C" void * sm_simu_crash_1_svc(void *, struct svc_req *);
+#define SM_NOTIFY ((u_int32_t)6)
+extern "C" void * sm_notify_1(struct stat_chge *, CLIENT *);
+extern "C" void * sm_notify_1_svc(struct stat_chge *, struct svc_req *);
+
+#elif __STDC__
+#define SM_STAT ((u_int32_t)1)
+extern  struct sm_stat_res * sm_stat_1(struct sm_name *, CLIENT *);
+extern  struct sm_stat_res * sm_stat_1_svc(struct sm_name *, struct svc_req *);
+#define SM_MON ((u_int32_t)2)
+extern  struct sm_stat_res * sm_mon_1(struct mon *, CLIENT *);
+extern  struct sm_stat_res * sm_mon_1_svc(struct mon *, struct svc_req *);
+#define SM_UNMON ((u_int32_t)3)
+extern  struct sm_stat * sm_unmon_1(struct mon_id *, CLIENT *);
+extern  struct sm_stat * sm_unmon_1_svc(struct mon_id *, struct svc_req *);
+#define SM_UNMON_ALL ((u_int32_t)4)
+extern  struct sm_stat * sm_unmon_all_1(struct my_id *, CLIENT *);
+extern  struct sm_stat * sm_unmon_all_1_svc(struct my_id *, struct svc_req *);
+#define SM_SIMU_CRASH ((u_int32_t)5)
+extern  void * sm_simu_crash_1(void *, CLIENT *);
+extern  void * sm_simu_crash_1_svc(void *, struct svc_req *);
+#define SM_NOTIFY ((u_int32_t)6)
+extern  void * sm_notify_1(struct stat_chge *, CLIENT *);
+extern  void * sm_notify_1_svc(struct stat_chge *, struct svc_req *);
+
+#else /* Old Style C */ 
+#define SM_STAT ((u_int32_t)1)
+extern  struct sm_stat_res * sm_stat_1();
+extern  struct sm_stat_res * sm_stat_1_svc();
+#define SM_MON ((u_int32_t)2)
+extern  struct sm_stat_res * sm_mon_1();
+extern  struct sm_stat_res * sm_mon_1_svc();
+#define SM_UNMON ((u_int32_t)3)
+extern  struct sm_stat * sm_unmon_1();
+extern  struct sm_stat * sm_unmon_1_svc();
+#define SM_UNMON_ALL ((u_int32_t)4)
+extern  struct sm_stat * sm_unmon_all_1();
+extern  struct sm_stat * sm_unmon_all_1_svc();
+#define SM_SIMU_CRASH ((u_int32_t)5)
+extern  void * sm_simu_crash_1();
+extern  void * sm_simu_crash_1_svc();
+#define SM_NOTIFY ((u_int32_t)6)
+extern  void * sm_notify_1();
+extern  void * sm_notify_1_svc();
+#endif /* Old Style C */ 
+
+#endif /* !_SM_INTER_H_RPCGEN */
diff -urN nfs-utils-1.0.7.old/utils/statd/sm_inter_clnt.c nfs-utils-1.0.7/utils/statd/sm_inter_clnt.c
--- nfs-utils-1.0.7.old/utils/statd/sm_inter_clnt.c	1970-01-01 01:00:00.000000000 +0100
+++ nfs-utils-1.0.7/utils/statd/sm_inter_clnt.c	2006-03-24 15:39:44.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "sm_inter.h"
+#include <string.h>
+#define SM_INTER_X
+
+/* Default timeout can be changed using clnt_control() */
+static struct timeval TIMEOUT = { 25, 0 };
+
+struct sm_stat_res *
+sm_stat_1(argp, clnt)
+	struct sm_name *argp;
+	CLIENT *clnt;
+{
+	static struct sm_stat_res clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, SM_STAT, (xdrproc_t) xdr_sm_name, (caddr_t) argp, (xdrproc_t) xdr_sm_stat_res, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+struct sm_stat_res *
+sm_mon_1(argp, clnt)
+	struct mon *argp;
+	CLIENT *clnt;
+{
+	static struct sm_stat_res clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, SM_MON, (xdrproc_t) xdr_mon, (caddr_t) argp, (xdrproc_t) xdr_sm_stat_res, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+struct sm_stat *
+sm_unmon_1(argp, clnt)
+	struct mon_id *argp;
+	CLIENT *clnt;
+{
+	static struct sm_stat clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, SM_UNMON, (xdrproc_t) xdr_mon_id, (caddr_t) argp, (xdrproc_t) xdr_sm_stat, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+struct sm_stat *
+sm_unmon_all_1(argp, clnt)
+	struct my_id *argp;
+	CLIENT *clnt;
+{
+	static struct sm_stat clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, SM_UNMON_ALL, (xdrproc_t) xdr_my_id, (caddr_t) argp, (xdrproc_t) xdr_sm_stat, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return (&clnt_res);
+}
+
+void *
+sm_simu_crash_1(argp, clnt)
+	void *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, SM_SIMU_CRASH, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
+
+void *
+sm_notify_1(argp, clnt)
+	struct stat_chge *argp;
+	CLIENT *clnt;
+{
+	static char clnt_res;
+
+	memset((char *)&clnt_res, 0, sizeof(clnt_res));
+	if (clnt_call(clnt, SM_NOTIFY, (xdrproc_t) xdr_stat_chge, (caddr_t) argp, (xdrproc_t) xdr_void, (caddr_t) &clnt_res, TIMEOUT) != RPC_SUCCESS) {
+		return (NULL);
+	}
+	return ((void *)&clnt_res);
+}
diff -urN nfs-utils-1.0.7.old/utils/statd/sm_inter_svc.c nfs-utils-1.0.7/utils/statd/sm_inter_svc.c
--- nfs-utils-1.0.7.old/utils/statd/sm_inter_svc.c	1970-01-01 01:00:00.000000000 +0100
+++ nfs-utils-1.0.7/utils/statd/sm_inter_svc.c	2006-03-24 15:39:44.000000000 +0100
@@ -0,0 +1,123 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "sm_inter.h"
+#include <stdio.h>
+#include <stdlib.h>/* getenv, exit */
+#include <signal.h>
+#include <memory.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <syslog.h>
+
+#ifdef __STDC__
+#define SIG_PF void(*)(int)
+#endif
+
+#ifdef DEBUG
+#define RPC_SVC_FG
+#endif
+
+#define _RPCSVC_CLOSEDOWN 120
+#define SM_INTER_X
+extern int _rpcpmstart;		/* Started by a port monitor ? */
+extern int _rpcfdtype;		/* Whether Stream or Datagram ? */
+extern int _rpcsvcdirty;	/* Still serving ? */
+
+static
+void _msgout(msg)
+	char *msg;
+{
+#ifdef RPC_SVC_FG
+	if (_rpcpmstart)
+		syslog(LOG_ERR, "%s", msg);
+	else
+		(void) fprintf(stderr, "%s\n", msg);
+#else
+	syslog(LOG_ERR, "%s", msg);
+#endif
+}
+
+void
+sm_prog_1(rqstp, transp)
+	struct svc_req *rqstp;
+	register SVCXPRT *transp;
+{
+	union {
+		struct sm_name sm_stat_1_arg;
+		struct mon sm_mon_1_arg;
+		struct mon_id sm_unmon_1_arg;
+		struct my_id sm_unmon_all_1_arg;
+		struct stat_chge sm_notify_1_arg;
+	} argument;
+	char *result;
+	bool_t (*xdr_argument)(), (*xdr_result)();
+	char *(*local)();
+
+	_rpcsvcdirty = 1;
+	switch (rqstp->rq_proc) {
+	case NULLPROC:
+		(void) svc_sendreply(transp, (xdrproc_t) xdr_void, (char *)NULL);
+		_rpcsvcdirty = 0;
+		return;
+
+	case SM_STAT:
+		xdr_argument = xdr_sm_name;
+		xdr_result = xdr_sm_stat_res;
+		local = (char *(*)()) sm_stat_1_svc;
+		break;
+
+	case SM_MON:
+		xdr_argument = xdr_mon;
+		xdr_result = xdr_sm_stat_res;
+		local = (char *(*)()) sm_mon_1_svc;
+		break;
+
+	case SM_UNMON:
+		xdr_argument = xdr_mon_id;
+		xdr_result = xdr_sm_stat;
+		local = (char *(*)()) sm_unmon_1_svc;
+		break;
+
+	case SM_UNMON_ALL:
+		xdr_argument = xdr_my_id;
+		xdr_result = xdr_sm_stat;
+		local = (char *(*)()) sm_unmon_all_1_svc;
+		break;
+
+	case SM_SIMU_CRASH:
+		xdr_argument = xdr_void;
+		xdr_result = xdr_void;
+		local = (char *(*)()) sm_simu_crash_1_svc;
+		break;
+
+	case SM_NOTIFY:
+		xdr_argument = xdr_stat_chge;
+		xdr_result = xdr_void;
+		local = (char *(*)()) sm_notify_1_svc;
+		break;
+
+	default:
+		svcerr_noproc(transp);
+		_rpcsvcdirty = 0;
+		return;
+	}
+	(void) memset((char *)&argument, 0, sizeof (argument));
+	if (!svc_getargs(transp, (xdrproc_t) xdr_argument, (caddr_t) &argument)) {
+		svcerr_decode(transp);
+		_rpcsvcdirty = 0;
+		return;
+	}
+	result = (*local)(&argument, rqstp);
+	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) xdr_result, result)) {
+		svcerr_systemerr(transp);
+	}
+	if (!svc_freeargs(transp, (xdrproc_t) xdr_argument, (caddr_t) &argument)) {
+		_msgout("unable to free arguments");
+		exit(1);
+	}
+	_rpcsvcdirty = 0;
+	return;
+}
diff -urN nfs-utils-1.0.7.old/utils/statd/sm_inter_xdr.c nfs-utils-1.0.7/utils/statd/sm_inter_xdr.c
--- nfs-utils-1.0.7.old/utils/statd/sm_inter_xdr.c	1970-01-01 01:00:00.000000000 +0100
+++ nfs-utils-1.0.7/utils/statd/sm_inter_xdr.c	2006-03-24 15:39:44.000000000 +0100
@@ -0,0 +1,162 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "sm_inter.h"
+
+bool_t
+xdr_sm_name(xdrs, objp)
+	XDR *xdrs;
+	sm_name *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_string(xdrs, &objp->mon_name, SM_MAXSTRLEN)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_my_id(xdrs, objp)
+	XDR *xdrs;
+	my_id *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_string(xdrs, &objp->my_name, SM_MAXSTRLEN)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_int(xdrs, &objp->my_prog)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_int(xdrs, &objp->my_vers)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_int(xdrs, &objp->my_proc)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_mon_id(xdrs, objp)
+	XDR *xdrs;
+	mon_id *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_string(xdrs, &objp->mon_name, SM_MAXSTRLEN)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_my_id(xdrs, &objp->my_id)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_mon(xdrs, objp)
+	XDR *xdrs;
+	mon *objp;
+{
+
+	 register int32_t *buf;
+
+	 int i;
+	 if (!xdr_mon_id(xdrs, &objp->mon_id)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_opaque(xdrs, objp->priv, SM_PRIV_SIZE)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_stat_chge(xdrs, objp)
+	XDR *xdrs;
+	stat_chge *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_string(xdrs, &objp->mon_name, SM_MAXSTRLEN)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_int(xdrs, &objp->state)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_sm_stat(xdrs, objp)
+	XDR *xdrs;
+	sm_stat *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_int(xdrs, &objp->state)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_res(xdrs, objp)
+	XDR *xdrs;
+	res *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_sm_stat_res(xdrs, objp)
+	XDR *xdrs;
+	sm_stat_res *objp;
+{
+
+	 register int32_t *buf;
+
+	 if (!xdr_res(xdrs, &objp->res_stat)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_int(xdrs, &objp->state)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+
+bool_t
+xdr_status(xdrs, objp)
+	XDR *xdrs;
+	status *objp;
+{
+
+	 register int32_t *buf;
+
+	 int i;
+	 if (!xdr_string(xdrs, &objp->mon_name, SM_MAXSTRLEN)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_int(xdrs, &objp->state)) {
+		 return (FALSE);
+	 }
+	 if (!xdr_opaque(xdrs, objp->priv, SM_PRIV_SIZE)) {
+		 return (FALSE);
+	 }
+	return (TRUE);
+}
+#define SM_INTER_X
